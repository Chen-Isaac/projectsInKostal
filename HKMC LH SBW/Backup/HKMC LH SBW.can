/*@!Encoding:936*/
includes
{
  #include "D:\\Isaac\\Library\\KostalSoftwareTestLibrary.cin"
}

variables
{
  
}

export testcase readSwVer (void) {
  stateMachine("readSwVer",routeNum,noParaPick);
}


export void setIgnStatus (int ignStatus)
{
   float volt;
   sysvar::VTS::M9_Ch4.SetStimulationMode(0);//stim mode inactive
   if (ignStatus) {//IGN connects to BATT
      sysvar::VTS::M9_Ch4.SetCurveType(0);//set curve type as constant
      volt = random(6)+7.5;
      sysvar::VTS::M9_Ch4.SetPWMVoltageHigh(volt > 12? 12:volt);//set voltagehigh 7-12
      //sysvar::VTS::M9_Ch4.SetPWMVoltageHigh(random(2)+7);
      @sysvar::VTS::M9_Ch4::DigitalOutput = 1;//output digital=1
      sysvar::VTS::M9_Ch4.SetStimulationMode(1);//stim mode as voltage 
      testWaitForTimeout(1000);
      TestStep("IGN status","IGN on, IGN voltage = %4.2fv",@sysvar::VTS::M9_Ch4::Avg);
   }
   else {//IGN connects to GND
      sysvar::VTS::M9_Ch4.SetCurveType(0);//set curve type as constant
      sysvar::VTS::M9_Ch4.SetPWMVoltageLow(random(5));//set voltagelow 0-4
      @sysvar::VTS::M9_Ch4::DigitalOutput = 0;//output digital=0
      sysvar::VTS::M9_Ch4.SetStimulationMode(1);////stim mode as voltage
      testWaitForTimeout(1000);
      TestStep("IGN status","IGN off, IGN voltage = %4.2fv",@sysvar::VTS::M9_Ch4::Avg);
   }
}

export void setAccStatus (int accStatus)
{
   int status;
   sysvar::VTS::M9_Ch5.SetStimulationMode(0);//stim mode inactive
   if (accStatus) {
      //ACC connects to BATT
      TestStep("hardwire status","ACC connects to BATT");
      sysvar::VTS::M9_Ch5.SetCurveType(0);//set curve type as constant
      sysvar::VTS::M9_Ch5.SetPWMVoltageHigh(random(6)+7);//set voltagelow 7-12
      @sysvar::VTS::M9_Ch5::DigitalOutput = 1;//output digital=1
      sysvar::VTS::M9_Ch5.SetStimulationMode(1);//stim mode as voltage 
      //CF_Gway_IGNSw=2(ACC) or 3(IG)
      $CF_Gway_IGNSw = random(2)+2;
      testWaitForTimeout(50);
      TestStep("CF_Gway_IGNSw status","CF_Gway_IGNSw = %1.0f",getSignal(CF_Gway_IGNSw));
   }
   else {
      if (random(2)) {
         //ACC connects to GND  
         TestStep("hardwire status","ACC connects to GND");
         sysvar::VTS::M9_Ch5.SetCurveType(0);//set curve type as constant
         sysvar::VTS::M9_Ch5.SetPWMVoltageLow(random(5));//set voltagelow 0-4
         @sysvar::VTS::M9_Ch5::DigitalOutput = 0;//output digital=0
         sysvar::VTS::M9_Ch5.SetStimulationMode(1);//stim mode as voltage
      }
      else {
         //CF_Gway_IGNSw!=2(ACC) and 3(IG)
         status=random(2);
         status=status*(random(4)+4)+(1-status)*random(2);
         setSignal(CF_Gway_IGNSw,status);
         testWaitForTimeout(50);
         TestStep("CF_Gway_IGNSw status","CF_Gway_IGNSw = %d",status);
      }
   }
}

export void setEngineRunningWithAllDoorsClosed (void)
{
   $ENG_STAT=3;//set engine running
   setDriverDoorStatus(0);
   $CF_Gway_AstDrSw=0;
   $CF_Gway_RLDrSw=0;
   $CF_Gway_RRDrSw=0;
   testWaitForTimeout(1000);
}

export void setDriverDoorStatus (int driverDoorOpen)
{
   if (driverDoorOpen) {
      if (random(2)) {
         //DOOR_OPEN connects to GND
         TestStep("hardwire status","DOOR_OPEN connects to GND");
         @sysvar::VTS::M9_Ch8::RelayGnd = 1;
      }
      else {
         //CF_Gway_DrvDrSw == 0x1(Open)
         $CF_Gway_DrvDrSw = 1;
         testWaitForTimeout(50);
         TestStep("CF_Gway_DrvDrSw status","CF_Gway_DrvDrSw = 1");
      }
   }
   else {
      //Set driver door hard wire float
      @sysvar::VTS::M9_Ch8::RelayGnd = 0;
      TestStep("hardwire status","DOOR_OPEN float");
      //Set CF_Gway_DrvDrSw != 0x1(Open)
      $CF_Gway_DrvDrSw = (random(2)*(random(2)+2));
      testWaitForTimeout(50);
      TestStep("CF_Gway_DrvDrSw status","CF_Gway_DrvDrSw = %1.0f",$CF_Gway_DrvDrSw);
   }
}

export void openDoorAccordingToLevel (int level)
{
   if (toUpper((char)level) == 'A') {
      switch (random(4)) {
         case 0:
            $CF_Gway_AstDrSw = 1;
            testStep("open door(Level A)", "CF_Gway_AstDrSw = open");
         break;
         case 1:
            $CF_Gway_RLDrSw = 1;
            testStep("open door(Level A)", "CF_Gway_RLDrSw = open");
         break;
         case 2:
            $CF_Gway_RRDrSw = 1;
            testStep("open door(Level A)", "CF_Gway_RRDrSw = open");
         break;
         case 3:
            setDriverDoorStatus(1);
            testStep("open door(Level A)", "set driver door open");
         break;
      }   
   }
   else if (toUpper((char)level) == 'B') {
      switch (random(3)) {
         case 0:
            $CF_Gway_AstDrSw = 1;
            testStep("open door(Level B)", "CF_Gway_AstDrSw = open");
         break;
         case 1:
            $CF_Gway_RLDrSw = 1;
            testStep("open door(Level B)", "CF_Gway_RLDrSw = open");
         break;
         case 2:
            $CF_Gway_RRDrSw = 1;
            testStep("open door(Level B)", "CF_Gway_RRDrSw = open");
         break;
      }
   }
   else 
      testStep("unknown door open level", "all doors kept closed.");
   testWaitForTimeout(1000);   
}

export void setBrakeStatus (int brakeStatus)
{
   if (brakeStatus) {
      @sysvar::VTS::M9_Ch1::RelayVBatt = 1;//Brake ON -- High
      if (testWaitForSignalMatch(CF_Lvr_BkeAct,1,2000))
         testStepPass("Brake status","Brake on:CF_Lvr_BkeAct=1");
      else
         testStepFail("Brake status","setting brake on occurs failure.");
   }
   else {
      @sysvar::VTS::M9_Ch1::RelayVBatt = 0;//Brake OFF -- Floating
      if (testWaitForSignalMatch(CF_Lvr_BkeAct,0,2000))
         testStepPass("Brake status","Brake off:CF_Lvr_BkeAct=0");
      else
         testStepFail("Brake status","setting brake off occurs failure.");
   }
}

export void parkSwitchPress (int parkSwitchPressValid, char fileName[])
{
   //fileName[elCount(fileName)-1] = '\0';
   if (parkSwitchPressValid) {
      // A valid P switch press
      // the park switch is not earlier pressed than the brake switch ON.
      setBrakeStatus (1);//brake on
      testValidateTesterConfirmation("Press Park Switch","Press ok then press Park Switch",1);
      checkLeverPositionSendToTcu(1);//check valid P press
      testWaitForTimeout(500);
      testReportAddWindowCapture("Graphics","","CF_Lvr_PosInf after valid P switch press",fileName);
      testWaitForTimeout(500);
      setBrakeStatus (0);//brake off
   }
   else {
      //An invalid P switch press
      //the park switch is earlier pressed than the brake switch ON
      testValidateTesterConfirmation("Press Park Switch","Press ok then press Park Switch",1);
      checkLeverPositionSendToTcu(1);//check valid P press
      testWaitForTimeout(500);
      testReportAddWindowCapture("Graphics","","CF_Lvr_PosInf after invalid P switch press",fileName);
      setBrakeStatus (1);//brake on
      testWaitForTimeout(2000);
      setBrakeStatus (0);//brake off
   }
}

export void parkReleaseSwitchPress (int parkReleaseSwitchValid)
{
   if (parkReleaseSwitchValid) {
      //A valid P-Release switch press
      //the P-Release switch is not earlier pressed than the brake switch ON.
      setBrakeStatus (1);//brake on
      testValidateTesterConfirmation("Press P-Release Switch","Press P-Release Switch then press ok",1);
      testWaitForTimeout(500);
      setBrakeStatus (0);//brake off
   }
   else {
      //An invalid P-Release switch press
      //the P-Release switch is earlier pressed than the brake switch ON
      testValidateTesterConfirmation("Press P-Release Switch","Press P-Release Switch then press ok",1);
      setBrakeStatus (1);//brake on
      testWaitForTimeout(2000);
      setBrakeStatus (0);//brake off
   }
}

export void checkLeverPositionSendToTcu (int vehicleGearPosStatus)
{
   int result;
   switch (vehicleGearPosStatus) {
      case 1:  //Lever position at P
         testStep("Lever operation", "Lever position at P");
         result = testWaitForSignalMatch(CF_Lvr_PosInf,1,5000) && testWaitForSignalMatch(CF_Lvr_PosCpl,14,5000);
         if (result!=1)
            testStepFail("Lever position at P", "Correct status should be CF_Lvr_PosInf = 1,CF_Lvr_PosCpl = 14.But fact is CF_Lvr_PosInf = %2.0f,CF_Lvr_PosCpl = %2.0f.",$CF_Lvr_PosInf,$CF_Lvr_PosCpl);
         else
            testStepPass("Lever position at P", "CF_Lvr_PosInf = %2.0f,CF_Lvr_PosCpl = %2.0f.", $CF_Lvr_PosInf,$CF_Lvr_PosCpl);  
         result = testWaitForSignalInRange(sysvar::VTS::M9_Ch3::PWMDC,9.7,10.3,30);
         if (result!=1) 
            testStepFail("PWMDC measurement", "PWMDC = %3.1f%%,out of range.", @sysvar::VTS::M9_Ch3::PWMDC);
         else
            testStepPass("PWMDC measurement", "PWMDC = %3.1f%%.", @sysvar::VTS::M9_Ch3::PWMDC);
         result = testWaitForSignalInRange(sysvar::VTS::M9_Ch3::PWMFreq,97,103,30);
         if (result!=1) 
            testStepFail("PWMFreq measurement", "PWMFreq = %3.1fHz,out of range.", @sysvar::VTS::M9_Ch3::PWMFreq);
         else
            testStepPass("PWMFreq measurement", "PWMFreq = %3.1fHz.", @sysvar::VTS::M9_Ch3::PWMFreq);
      break;
      case 2: //Lever position at R
         testStep("Lever operation", "Lever position at R");
         result = testWaitForSignalMatch(CF_Lvr_PosInf,3,5000) && testWaitForSignalMatch(CF_Lvr_PosCpl,12,5000);
         if (result!=1) 
            testStepFail("Lever position at R", "Correct status should be CF_Lvr_PosInf = 3,CF_Lvr_PosCpl = 12.But fact is CF_Lvr_PosInf = %2.0f,CF_Lvr_PosCpl = %2.0f.",$CF_Lvr_PosInf,$CF_Lvr_PosCpl);
         else
            testStepPass("Lever position at R", "CF_Lvr_PosInf = %2.0f,CF_Lvr_PosCpl = %2.0f.", $CF_Lvr_PosInf,$CF_Lvr_PosCpl);
         result=testWaitForSignalInRange(sysvar::VTS::M9_Ch3::PWMDC,19.4,20.6,30);
         if (result!=1)
            testStepFail("PWMDC measurement", "PWMDC = %3.1f%%,out of range.", @sysvar::VTS::M9_Ch3::PWMDC);
         else
            testStepPass("PWMDC measurement", "PWMDC = %3.1f%%.", @sysvar::VTS::M9_Ch3::PWMDC);
         result=testWaitForSignalInRange(sysvar::VTS::M9_Ch3::PWMFreq,97,103,30);
         if (result!=1) 
            testStepFail("PWMFreq measurement", "PWMFreq = %3.1fHz,out of range.", @sysvar::VTS::M9_Ch3::PWMFreq);
         else
            testStepPass("PWMFreq measurement", "PWMFreq = %3.1fHz.", @sysvar::VTS::M9_Ch3::PWMFreq);
      break;
      case 3: //Lever position at Nr
         testStep("Lever operation", "Lever position at Nr");
         result=testWaitForSignalMatch(CF_Lvr_PosInf,8,5000) && testWaitForSignalMatch(CF_Lvr_PosCpl,7,5000);
         if (result!=1)
            testStepFail("Lever position at R", "Correct status should be CF_Lvr_PosInf = 8,CF_Lvr_PosCpl = 7.But fact is CF_Lvr_PosInf = %2.0f,CF_Lvr_PosCpl = %2.0f.",$CF_Lvr_PosInf,$CF_Lvr_PosCpl);
         else
            testStepPass("Lever position at R", "CF_Lvr_PosInf = %2.0f,CF_Lvr_PosCpl = %2.0f.", $CF_Lvr_PosInf,$CF_Lvr_PosCpl);
         result=testWaitForSignalInRange(sysvar::VTS::M9_Ch3::PWMDC,29.1,30.9,30);
         if (result!=1)
            testStepFail("PWMDC measurement", "PWMDC = %3.1f%%,out of range.", @sysvar::VTS::M9_Ch3::PWMDC);
         else
            testStepPass("PWMDC measurement", "PWMDC = %3.1f%%.", @sysvar::VTS::M9_Ch3::PWMDC);
         result=testWaitForSignalInRange(sysvar::VTS::M9_Ch3::PWMFreq,97,103,30);
         if (result!=1)
            testStepFail("PWMFreq measurement", "PWMFreq = %3.1fHz,out of range.", @sysvar::VTS::M9_Ch3::PWMFreq);
         else
            testStepPass("PWMFreq measurement", "PWMFreq = %3.1fHz.", @sysvar::VTS::M9_Ch3::PWMFreq);
      break;
      case 4: //Lever position at Nd
         testStep("Lever operation", "Lever position at Nd");
         result=testWaitForSignalMatch(CF_Lvr_PosInf,9,5000) && testWaitForSignalMatch(CF_Lvr_PosCpl,6,5000);
         if (result!=1) 
            testStepFail("Lever position at R", "Correct status should be CF_Lvr_PosInf = 9,CF_Lvr_PosCpl = 6.But fact is CF_Lvr_PosInf = %2.0f,CF_Lvr_PosCpl = %2.0f.",$CF_Lvr_PosInf,$CF_Lvr_PosCpl);
         else
            testStepPass("Lever position at R", "CF_Lvr_PosInf = %2.0f,CF_Lvr_PosCpl = %2.0f.",$CF_Lvr_PosInf,$CF_Lvr_PosCpl);
         result = testWaitForSignalInRange(sysvar::VTS::M9_Ch3::PWMDC,38.8,41.2,30);
         if (result!=1) 
            testStepFail("PWMDC measurement", "PWMDC = %3.1f%%,out of range.", @sysvar::VTS::M9_Ch3::PWMDC);
         else
            testStepPass("PWMDC measurement", "PWMDC = %3.1f%%.", @sysvar::VTS::M9_Ch3::PWMDC);
         result=testWaitForSignalInRange(sysvar::VTS::M9_Ch3::PWMFreq,97,103,30);
         if (result!=1) 
            testStepFail("PWMFreq measurement", "PWMFreq = %3.1fHz,out of range.", @sysvar::VTS::M9_Ch3::PWMFreq);
         else
            testStepPass("PWMFreq measurement", "PWMFreq = %3.1fHz.", @sysvar::VTS::M9_Ch3::PWMFreq);
        
      break;
      case 5: //Lever position at D
         testStep("Lever operation", "Lever position at D");
         result=testWaitForSignalMatch(CF_Lvr_PosInf,7,5000) && testWaitForSignalMatch(CF_Lvr_PosCpl,8,5000);
         if (result!=1) 
            testStepFail("Lever position at R",  "Correct status should be CF_Lvr_PosInf = 7,CF_Lvr_PosCpl = 8.But fact is CF_Lvr_PosInf = %2.0f,CF_Lvr_PosCpl = %2.0f.",$CF_Lvr_PosInf,$CF_Lvr_PosCpl);
         else
            testStepPass("Lever position at R",  "CF_Lvr_PosInf = %2.0f,CF_Lvr_PosCpl = %2.0f.",$CF_Lvr_PosInf,$CF_Lvr_PosCpl);
         result=testWaitForSignalInRange(sysvar::VTS::M9_Ch3::PWMDC,48.5,51.5,30);
         if (result!=1)
            testStepFail("PWMDC measurement", "PWMDC = %3.1f%%,out of range.", @sysvar::VTS::M9_Ch3::PWMDC);
         else
            testStepPass("PWMDC measurement", "PWMDC = %3.1f%%.", @sysvar::VTS::M9_Ch3::PWMDC);
         result=testWaitForSignalInRange(sysvar::VTS::M9_Ch3::PWMFreq,97,103,30);
         if (result!=1) 
            testStepFail("PWMFreq measurement", "PWMFreq = %3.1fHz,out of range.", @sysvar::VTS::M9_Ch3::PWMFreq);
         else
            testStepPass("PWMFreq measurement", "PWMFreq = %3.1fHz.", @sysvar::VTS::M9_Ch3::PWMFreq);
      break;
      default:
      break;
   }  
}

export void unlockSWHandling (int unlockSWValid)
{
   if (unlockSWValid) {//press knob  
      if (testWaitForSignalMatch(CF_Lvr_UlkButStat,2,1000)==1)
         testStepPass("CF_Lvr_UlkButStat status","CF_Lvr_UlkButStat = 2,safty button on.");
      else
         testStepFail("CF_Lvr_UlkButStat status","CF_Lvr_UlkButStat = %1.0f !=2.",$CF_Lvr_UlkButStat);
   }
   else {//release knob
      if (testWaitForSignalMatch(CF_Lvr_UlkButStat,1,1000)==1)
         testStepPass("CF_Lvr_UlkButStat status","CF_Lvr_UlkButStat = 1,safty button off.");
      else
         testStepFail("CF_Lvr_UlkButStat status","CF_Lvr_UlkButStat = %1.0f !=1.",$CF_Lvr_UlkButStat);
   }    
}

export void SBWControlPRAByIGONTCURequest (int PRAPosStatus)
{
   if (PRAPosStatus) {
      //SBW operate PRA to ¡°P position¡± 
      $CF_Tcu_PRelReq=1;
      testWaitForTimeout(500);
      $CF_Tcu_PRelReq=0; //SBW receives CF_Tcu_PrelReq = 0x0 (1->0 edge) 
      testStep("PRAPosStatus","to P position:receives CF_Tcu_PrelReq = 0x0 (1->0 edge) from TCU.");
   }
   else {
      //SBW operate PRA to Not P position
      $CF_Tcu_PRelReq=0;
      testWaitForTimeout(500);
      $CF_Tcu_PRelReq=1; //SBW received CF_Tcu_PrelReq = 0x1(0->1 edge) from TCU 
      testStep("PRAPosStatus","to Not P position:received CF_Tcu_PrelReq = 0x1(0->1 edge) from TCU,while P switch is not pressed."); 
   }
}

export void setVehicleSpeed (int vehicleSpeedOutputValid,int vehicleStopBool)
{
   If (vehicleSpeedOutputValid) {
      if (random(2)) {
         //VS_TCU signal occurs valid value
         TestStep("vehicleSpeedOutputValid","VS_TCU signal occurs valid value,WHL_SPD_FL whatever");
	       testEnableMsg("TCU12"); 
         if (vehicleStopBool)
            setSignal(VS_TCU,random(3));
         else
            setSignal(VS_TCU,random(252)+3);
         testWaitForTimeout(50);
         TestStep("VS_TCU status","VS_TCU = %3.0f",$VS_TCU);
         //WHL_SPD_FL whatever
	       if (random(2)) {
	       //case:WHL_SPD11 NOT timeout
		        testEnableMsg("WHL_SPD11");
	          setSignal(WHL_SPD_FL,random(16384));
            testWaitForTimeout(50);
            TestStep("WHL_SPD_FL status","WHL_SPD_FL = %5.0f",$WHL_SPD_FL);
         }
	       else {
	          TestDisableMsg("WHL_SPD11");//case:WHL_SPD11 timeout
            TestStep("WHL_SPD_FL status","WHL_SPD_FL = timeout");
         }
      }
      else {
         //VS_TCU signal occurs timeout or error value,WHL_SPD_FL is valid
         TestStep("vehicleSpeedOutputValid","VS_TCU signal occurs timeout or error value,WHL_SPD_FL is valid");
	       if (random(2)) {
	        //VS_TCU signal occurs timeout
	          TestDisableMsg("TCU12");
            TestStep("VS_TCU status","VS_TCU = timeout");
	       }
	       else {
	        //VS_TCU signal occurs error value
	          testEnableMsg("TCU12");
		        setSignal(VS_TCU,0xff);
            TestStep("VS_TCU status","VS_TCU = 0xff = error");
	       }
	       //WHL_SPD_FL is valid
	       testEnableMsg("WHL_SPD11"); 
         if (vehicleStopBool)
            setSignal(WHL_SPD_FL,random(65));
         else
            setSignal(WHL_SPD_FL,random(16318)+65);
         testWaitForTimeout(50);
         TestStep("WHL_SPD_FL status","WHL_SPD_FL = %5.0f",getSignal(WHL_SPD_FL));
      }
   }
   else {
      //SBW shall consider keep last valid value.
      //both VS_TCU and WHL_SPD_FL are timeout or error value
      TestStep("vehicleSpeedOutputInvalid","both VS_TCU and WHL_SPD_FL are timeout or error value");
      if (random(2)) {
         TestDisableMsg("TCU12");//VS_TCU signal occurs timeout
         TestStep("VS_TCU status","VS_TCU = timeout");
      }
      else  {//VS_TCU signal occurs error value
         testEnableMsg("TCU12");
         setSignal(VS_TCU,0xff);
         TestStep("VS_TCU status","VS_TCU = 0xff = error");
      }
      if (random(2)) {
         TestDisableMsg("WHL_SPD11");//WHL_SPD_FL signal occurs timeout
         TestStep("WHL_SPD_FL status","WHL_SPD_FL = timeout");
      }
      else {
         testEnableMsg("WHL_SPD11");
         setSignal(WHL_SPD_FL,0x3fff);//WHL_SPD_FL signal occurs error value
         TestStep("WHL_SPD_FL status","WHL_SPD_FL = 0x3fff = error");
      }
   }
}

export void setVehicleGearPos (int vehicleGearPosOutputValid,int canSigTimeoutBool,int vehicleGearPosStatus)
{
   int G_SEL_DISP_value;
   if (vehicleGearPosOutputValid) {
      if (canSigTimeoutBool) {
         //G_SEL_DISP signal is timeout,PWM from TCU is valid
         testStep("vehicleGearPosOutputValid", "G_SEL_DISP signal is timeout,PWM from TCU is valid");
         testDisableMsg("TCU11");//G_SEL_DISP signal is timeout
         //PWM from TCU is valid
         sysvar::VTS::M9_Ch2.SetStimulationMode(0);//stim mode inactive
         sysvar::VTS::M9_Ch2.SetPWMVoltageLow(random(3)+1);//set voltagelow 1-3
         sysvar::VTS::M9_Ch2.SetPWMVoltageHigh(random(9)+7);//set voltagehigh 7-15 
         sysvar::VTS::M9_Ch2.SetCurveType(1);//set curve type as PWM
         @sysvar::VTS::M9_Ch2::PWMOutputFreq = 100;//PWM output Freq =100Hz
         switch (vehicleGearPosStatus) {
            case 1: //P duty=10%
            @sysvar::VTS::M9_Ch2::PWMOutputDC = 10;
            break;
            case 2: //R duty=20%
            @sysvar::VTS::M9_Ch2::PWMOutputDC = 20;
            break;
            case 3: //N duty=30%
            @sysvar::VTS::M9_Ch2::PWMOutputDC = 30;
            break;
            case 4: //D duty=40%
            @sysvar::VTS::M9_Ch2::PWMOutputDC = 40;
            break;
            default: 
            break;
         }
         sysvar::VTS::M9_Ch2.SetStimulationMode(1);//stim mode as voltage
         sysvar::VTS::M9_Ch2.StartStimulation();
         testWaitForTimeout(50);
         testStep("PWM status", "PWMOutputDC = %2.0f",SysGetVariableFloat(sysvar::VTS::M9_Ch2::PWMOutputDC));
      }
      else {
         //G_SEL_DISP signal is valid,PWM from TCU whatever
         testStep("vehicleGearPosOutputValid", "G_SEL_DISP signal is valid,PWM from TCU whatever");
	       //G_SEL_DISP signal is valid
	       testEnableMsg("TCU11");
         switch (vehicleGearPosStatus) {
            case 1: //P 0x0
            setSignal(G_SEL_DISP,0);
            break;
            case 2: //R 0x7
            setSignal(G_SEL_DISP,7);
            break;
            case 3: //N 0x6
            setSignal(G_SEL_DISP,6);
            break;
            case 4: //D 0x5 0x8
            setSignal(G_SEL_DISP,random(2)*3+5);
            break;
            default: 
            break;
         }
         testWaitForTimeout(50);
         testStep("G_SEL_DISP status", "G_SEL_DISP = %2.0f",getSignal(G_SEL_DISP));
	       //PWM from TCU whatever
	       if (random(2)) {
            testStep("PWM status", "PWM timeout,stim mode inactive");
	          sysvar::VTS::M9_Ch2.SetStimulationMode(0);//PWM timeout,stim mode inactive
	       }
	       else {
	          sysvar::VTS::M9_Ch2.SetStimulationMode(0);//stim mode inactive
            sysvar::VTS::M9_Ch2.SetPWMVoltageLow(random(3)+1);//set voltagelow 1-3
            sysvar::VTS::M9_Ch2.SetPWMVoltageHigh(random(9)+7);//set voltagehigh 7-15 
            sysvar::VTS::M9_Ch2.SetCurveType(1);//set curve type as PWM
            @sysvar::VTS::M9_Ch2::PWMOutputFreq = 100;//PWM output Freq =100Hz
		        @sysvar::VTS::M9_Ch2::PWMOutputDC = random(101);
            testWaitForTimeout(50);
            testStep("PWM status", "PWMOutputDC=%3.0f,PWMOutputFreq = 100",SysGetVariableFloat(sysvar::VTS::M9_Ch2::PWMOutputDC));
		        sysvar::VTS::M9_Ch2.SetStimulationMode(1);//stim mode as voltage
            sysvar::VTS::M9_Ch2.StartStimulation();
	       }
      }
   }
   else {
      if (canSigTimeoutBool) {
         //G_SEL_DISP signal is timeout,PWM from TCU is invalid
         testStep("vehicleGearPosOutputInvalid", "G_SEL_DISP signal is timeout,PWM from TCU is invalid");
         testDisableMsg("TCU11");//G_SEL_DISP signal is timeout
         //PWM from TCU is invalid
         sysvar::VTS::M9_Ch2.SetStimulationMode(0);//stim mode inactive
         sysvar::VTS::M9_Ch2.SetPWMVoltageLow(random(3)+1);//set voltagelow 1-3
         sysvar::VTS::M9_Ch2.SetPWMVoltageHigh(random(9)+7);//set voltagehigh 7-15 
         sysvar::VTS::M9_Ch2.SetCurveType(1);//set curve type as PWM
         @sysvar::VTS::M9_Ch2::PWMOutputFreq = 100;//PWM output Freq =100Hz
         @sysvar::VTS::M9_Ch2::PWMOutputDC = random(54)+43;
         testWaitForTimeout(50);
         testStep("PWM status", "PWMOutputDC=%3.0f,PWMOutputFreq = 100",SysGetVariableFloat(sysvar::VTS::M9_Ch2::PWMOutputDC));
         sysvar::VTS::M9_Ch2.SetStimulationMode(1);//stim mode as voltage
         sysvar::VTS::M9_Ch2.StartStimulation();
      }
      else {
         //G_SEL_DISP signal is not recognized or fault,PWM from TCU whatever
         testStep("vehicleGearPosOutputInvalid", "G_SEL_DISP signal is not recognized or fault,PWM from TCU whatever");
	       testEnableMsg("TCU11");
	       G_SEL_DISP_value = random(2);
	       G_SEL_DISP_value = G_SEL_DISP_value*(random(4)+1)+(1-G_SEL_DISP_value)*(random(7)+9);
	       setSignal(G_SEL_DISP,G_SEL_DISP_value);
         testStep("G_SEL_DISP status", "G_SEL_DISP=%d",G_SEL_DISP_value);
	       //PWM from TCU whatever
	       if (random(2)) {
            testStep("PWM status", "PWM timeout,stim mode inactive");
	          sysvar::VTS::M9_Ch2.SetStimulationMode(0);//PWM timeout,stim mode inactive
	       }
	       else {
	          sysvar::VTS::M9_Ch2.SetStimulationMode(0);//stim mode inactive
            sysvar::VTS::M9_Ch2.SetPWMVoltageLow(random(3)+1);//set voltagelow 1-3
            sysvar::VTS::M9_Ch2.SetPWMVoltageHigh(random(9)+7);//set voltagehigh 7-15 
            sysvar::VTS::M9_Ch2.SetCurveType(1);//set curve type as PWM
            @sysvar::VTS::M9_Ch2::PWMOutputFreq = 100;//PWM output Freq =100Hz
		        @sysvar::VTS::M9_Ch2::PWMOutputDC = random(101);
            testWaitForTimeout(50);
            testStep("PWM status", "PWMOutputDC=%3.0f,PWMOutputFreq = 100",SysGetVariableFloat(sysvar::VTS::M9_Ch2::PWMOutputDC));
		        sysvar::VTS::M9_Ch2.SetStimulationMode(1);//stim mode as voltage
            sysvar::VTS::M9_Ch2.StartStimulation();
	       }
      }
   }
}

export void setAutoNModeWhenIGNOn (int canSigTimeoutBool)
{
   int drivingCycle,learningTimes,G_SEL_DISP_value_of_notN,k;
   k = random(2);
   G_SEL_DISP_value_of_notN = random(2)+7;
   G_SEL_DISP_value_of_notN = random(2)*G_SEL_DISP_value_of_notN;
   G_SEL_DISP_value_of_notN = k*5+(1-k)*G_SEL_DISP_value_of_notN;
   //To enter this mode, such below condition should be satisfied to calculate the timing of moving from D to N.
   //While IGN ON, Vehicle stop, Engine Running, D gear, SBW shall record the time that driver move the gear from D to N if the time is less than 10s.
   setVehicleSpeed(1,1);
   testWaitForTimeout(1000);
   $ENG_STAT = 3;//set engine running
   testWaitForTimeout(1000);
   testStep("Engine status","set engine running, ENG_STAT = %1.0f",$ENG_STAT);
   testStep("IGN status","IGN ON, IGN voltage = %4.2fv",@sysvar::VTS::M9_Ch4::Avg);
   for (drivingCycle = 0; drivingCycle < 3; drivingCycle++) {
      //testValidateTesterConfirmation("","",1);
      //In last 3 times of driving cycle (IGN ON -> IGN OFF) and 20 value is recorded.
      for (learningTimes = 0; learningTimes < 7; learningTimes++) {
         //SBW shall record the time that driver move the gear from D to N if the time is less than 10s.
         setVehicleGearPos(1,canSigTimeoutBool,4);//set gear D
         testWaitForTimeout((random(5)+1)*1000);
         setVehicleGearPos(1,canSigTimeoutBool,3);//set gear N
         testWaitForTimeout(2000);
      }
      setIgnStatus(0);//IGN OFF
      testWaitForTimeout(1000);
      setIgnStatus(1);//IGN ON
      testWaitForTimeout(5000);
   }
   fromIGONToStandByMode(G_SEL_DISP_value_of_notN);
   loginRequestService();
   enterSleepModeWithDoorClosed();
}

export void setAutoNModeTestConditionAfterModeActived (int canSigTimeoutBool)
{
   //on the condition of Engine Running, Vehicle Stop, Gear=D and Brake On
   $ENG_STAT = 3;//set engine running
   testWaitForTimeout(1000);
   testStep("Engine status","set engine running, ENG_STAT = %1.0f",$ENG_STAT);
   setVehicleSpeed(1,1);//make vehicle stop
   testWaitForTimeout(1000);
   setVehicleGearPos(1,canSigTimeoutBool,4);//set gear D
   testWaitForTimeout(1000);
   setBrakeStatus(1);//set brake on
   
}

export void setIlluminationmode (int illuminationModeActive,int dayModeOn)
{
   if (illuminationModeActive) {
      testEnableMsg(CGW1);
      testEnableMsg(CGW_CP2);
      if (dayModeOn) {
         if (random(2)) {
            $CF_Gway_LightSwState = 0;  //receiving CF_Gway_LightSwState == 0x0(Light Sw Off)&&No CAN timeout
         }
         else {
            //receiving CF_Gway_LightSwState == 0x1(Tail Sw On) or 0x2(HeadLamp Low Sw On) or 0x3(AutoLight Sw On) && CF_Gway_DetentOut== 0x1:ON(Daytime Max)&&No CAN timeout  
            $CF_Gway_DetentOut = 1;
            $CF_Gway_LightSwState = random(3)+1;
         }
         testWaitForTimeout(50);
         testStep("illuminationModeStatus","SBW enter the day mode");
         testStep("CF_Gway_LightSwState","CF_Gway_LightSwState = %1.0f",$CF_Gway_LightSwState);
         testStep("CF_Gway_DetentOut","CF_Gway_DetentOut = %1.0f",$CF_Gway_DetentOut);
      }
      else {
         //receiving CF_Gway_LightSwState == 0x1(Tail Sw On) or 0x2(HeadLamp Low Sw On) or 0x3(AutoLight Sw On)&& CF_Gway_DetentOut== 0x0:OFF(Night Max)&& No CAN timeout
         $CF_Gway_DetentOut = 0;
         $CF_Gway_LightSwState = random(3)+1;
         testWaitForTimeout(50);
         testStep("illuminationModeStatus","SBW enter the night mode");
         testStep("CF_Gway_LightSwState","CF_Gway_LightSwState = %1.0f",$CF_Gway_LightSwState);
         testStep("CF_Gway_DetentOut","CF_Gway_DetentOut = %1.0f",$CF_Gway_DetentOut);
      }
   }
   else {
      //enter timeout 
      testStep("illuminationModeStatus","SBW enter the timeout mode");
      switch (random(2)) {
         case 0: 
            //CF_Gway_LightSwState timeout
            testDisableMsg(CGW1); 
            testStep("timeoutStatus","CF_Gway_LightSwState timeout");
         break;
         case 1: 
            //CF_Gway_DetentOut CF_Gway_RheostatLevel timeout
            testDisableMsg(CGW_CP2); 
            testStep("timeoutStatus","CF_Gway_DetentOut CF_Gway_RheostatLevel both timeout");
         break;
      }
   }
}

export void setPRAPos (int PRAOutputValid, int PRAPosStatusSetBySBW)
{
   @sysvar::VTS::M9_Ch6::RelayVBatt = 0;
   @sysvar::VTS::M9_Ch6::RelayGnd = 0;
   @sysvar::VTS::M9_Ch7::RelayVBatt = 0;
   @sysvar::VTS::M9_Ch7::RelayGnd = 0;
   sysvar::VTS::M9_Ch9.SetStimulationMode(0);//stim mode inactive
   sysvar::VTS::M9_Ch9.SetCurveType(0);//set curve type as constant
   sysvar::VTS::M9_Ch9.SetPWMVoltageHigh(2.83);//set voltagehigh 2.83V as Not P
   sysvar::VTS::M9_Ch9.SetPWMVoltageLow(1.275);//set voltagelow 1.275V as P
   if (PRAOutputValid) {
      if (PRAPosStatusSetBySBW) {
         //set PRA at P position
         //Make PRA sensor detects P position
         @sysvar::VTS::M9_Ch9::DigitalOutput = 0;//output digital=0
         sysvar::VTS::M9_Ch9.SetStimulationMode(1);////stim mode as voltage
         //Make T/M Switch detects P position
         //P signal is Low Level and Not P signal is High level presents T/M switch state is equal to ¡°P position¡±.
         @sysvar::VTS::M9_Ch6::RelayVBatt = 0;//P signal is not High level
         @sysvar::VTS::M9_Ch7::RelayGnd = 0;//Not P signal is not Low Level
         testWaitForTimeout(50);
         @sysvar::VTS::M9_Ch6::RelayGnd = 1;//P signal is Low Level
         @sysvar::VTS::M9_Ch7::RelayVBatt = 1;//Not P signal is High level
         testStep("PRAPosStatus","Valid:PRA sensor detects P position,T/M Switch detects P position.");
      }
      else {
         //set PRA at Not P position
         //Make PRA sensor detects Not P position
         @sysvar::VTS::M9_Ch9::DigitalOutput = 1;//output digital=0
         sysvar::VTS::M9_Ch9.SetStimulationMode(1);////stim mode as voltage
         //Make T/M Switch detects Not P position
         //P signal is High Level and Not P signal is Low level presents T/M switch state is equal to ¡°Not P position¡±.
         @sysvar::VTS::M9_Ch7::RelayVBatt = 0;//Not P signal is not High level
         @sysvar::VTS::M9_Ch6::RelayGnd = 0;//P signal is not Low Level
         testWaitForTimeout(50);
         @sysvar::VTS::M9_Ch7::RelayGnd = 1;//Not P signal is Low Level
         @sysvar::VTS::M9_Ch6::RelayVBatt = 1;//P signal is High level
         testStep("PRAPosStatus","Valid:PRA sensor detects Not P position,T/M Switch detects Not P position.");
      }
   }
   else {
      //consider PRA position failure.
      //not include PRA sensor detects error position
      switch (random(3)) {
         case 0: //T/M switch state is failure.P signal and Not P signal both are Low Level 
            @sysvar::VTS::M9_Ch6::RelayVBatt = 0;//P signal is not High level
            @sysvar::VTS::M9_Ch7::RelayVBatt = 0;//Not P signal is not High level
            testWaitForTimeout(50);
            @sysvar::VTS::M9_Ch7::RelayGnd = 1;//Not P signal is Low Level
            @sysvar::VTS::M9_Ch6::RelayGnd = 1;//P signal is Low Level    
            testStep("PRAPosStatus","failure:T/M switch state is failure.P signal and Not P signal both are Low Level.");
         break;
         case 1: //T/M switch state is failure.P signal and Not P signal both are High Level 
            @sysvar::VTS::M9_Ch7::RelayGnd = 0;//Not P signal is not Low Level
            @sysvar::VTS::M9_Ch6::RelayGnd = 0;//P signal is not Low Level    
            testWaitForTimeout(50);
            @sysvar::VTS::M9_Ch6::RelayVBatt = 1;//P signal is High level
            @sysvar::VTS::M9_Ch7::RelayVBatt = 1;//Not P signal is High level
            testStep("PRAPosStatus","failure:T/M switch state is failure.P signal and Not P signal both are High Level.");
         break;
         case 2: //PRA sensor detects a position which is different from T/M Switch
            if (PRAPosStatusSetBySBW) {
               //PRA sensor detects P,T/M Switch detects Not P position
               @sysvar::VTS::M9_Ch7::RelayVBatt = 0;//Not P signal is not High level
               @sysvar::VTS::M9_Ch6::RelayGnd = 0;//P signal is not Low Level
               testWaitForTimeout(50);
               @sysvar::VTS::M9_Ch7::RelayGnd = 1;//Not P signal is Low Level
               @sysvar::VTS::M9_Ch6::RelayVBatt = 1;//P signal is High level
               testStep("PRAPosStatus","failure:PRA sensor detects P,T/M Switch detects Not P position.");
            }
            else {
               //PRA sensor detects Not P,T/M Switch detects P position
               @sysvar::VTS::M9_Ch6::RelayVBatt = 0;//P signal is not High level
               @sysvar::VTS::M9_Ch7::RelayGnd = 0;//Not P signal is not Low Level
               testWaitForTimeout(50);
               @sysvar::VTS::M9_Ch6::RelayGnd = 1;//P signal is Low Level
               @sysvar::VTS::M9_Ch7::RelayVBatt = 1;//Not P signal is High level
               testStep("PRAPosStatus","failure:PRA sensor detects Not P,T/M Switch detects P position.");
            }
         break;
      
      }
   }

}

export void fromStandbyToNparkIGOffMode (void)
{
   parkReleaseSwitchPress(1);
   setVehicleSpeed(1,1);
   
}

export void fromIGONToIGOffMode (int G_SEL_DISP_value_of_notN)
{
   //Gear not N
   char gearStatus;
   $G_SEL_DISP = G_SEL_DISP_value_of_notN;
   switch (G_SEL_DISP_value_of_notN) {
      case 0: gearStatus = 'P'; break;
      case 5: gearStatus = 'D'; break;
      case 7: gearStatus = 'R'; break;
      case 8: gearStatus = 'D'; break;
   }
   testWaitForTimeout(100);
   setIgnStatus(0);//IG OFF
   testWaitForTimeout(500);
   testStep("Enter IG Off mode"," IGN voltage = %4.2fv,G_SEL_DISP = %c = %1.0f",@sysvar::VTS::M9_Ch4::Avg,gearStatus,$G_SEL_DISP);
}

export void fromIGONToGearNIGOffMode (void)
{
   $G_SEL_DISP=6;//Gear N
   testStep("G_SEL_DISP status","G_SEL_DISP = N");
   testWaitForTimeout(500);
   setIgnStatus(0);//IG OFF
}

export void fromIGONToNParkIGOffMode (int G_SEL_DISP_value_of_notN)
{
   fromIGONToIGOffMode(G_SEL_DISP_value_of_notN);
   testWaitForTimeout(100);
   setVehicleSpeed(1,1);//vehicle stop
   parkReleaseSwitchPress(1);
   testStep("Enter N park IG Off mode"," IGN voltage = %4.2fv,G_SEL_DISP = %1.0f",@sysvar::VTS::M9_Ch4::Avg,$G_SEL_DISP);
}

export void fromIGONToStandByMode (int G_SEL_DISP_value_of_notN)
{
   fromIGONToIGOffMode(G_SEL_DISP_value_of_notN);
   testWaitForTimeout(300);
   switch (random(3)) {
      case 0: 
         $CF_Gway_DrvKeyLockSw = 1; 
         testStep("enter standby mode","CF_Gway_DrvKeyLockSw = lock");
      break; //CF_Gway_DrvKeyLockSw = lock;
      case 1: 
         $CF_Gway_PassiveAccessLock = 1; 
         testStep("enter standby mode","CF_Gway_PassiveAccessLock = lock");
      break; //CF_Gway_PassiveAccessLock = lock;
      case 2: 
         $CF_Gway_RKECmd = 1; 
         testStep("enter standby mode","CF_Gway_RKECmd = lock");
      break; //CF_Gway_RKECmd = lock;
   }
}

export void loginRequestService(void)
{
   message Kostia_Request kostiaReq = {DLC=8};
   kostiaReq.long(0)=0x534f4b01;
   kostiaReq.long(4)=0x5f4c4154;
   output(kostiaReq);
   if (testWaitForMessage(Kostia_Response,200)==1) {
      testStep("Login-Request Service","kostiaReq = 0x%llx",$KostiaReq.raw64);
      if ($KostiaResp.raw64 == 0x5f4c4154534f4b01ll) 
         testStepPass("login success","kostiaResp = 0x%llx",$KostiaResp.raw64);
      else
         testStepFail("login fail","Wrong kostiaResp = 0x%llx",$KostiaResp.raw64);
   }
   else
      testStepFail("login fail","No kostiaResp");
}

export void enterTestMode(void)
{
   message Kostia_Request kostiaReq = {DLC=8};
   kostiaReq.long(0)=0x4f4d0303;
   kostiaReq.long(4)=0x45575544;
   output(kostiaReq);
   if (testWaitForMessage(Kostia_Response,100)==1) {
      testStep("enter test mode: change mode request ","kostiaReq = 0x%llx",$KostiaReq.raw64);
      if ($KostiaResp.raw64 == 0x455755444f4d0303ll)
         testStepPass("enter test mode temporary success","kostiaResp = 0x%llx",$KostiaResp.raw64);
      else
         testStepFail("enter test mode temporary fail","Wrong kostiaResp = 0x%llx",$KostiaResp.raw64);
   }
   else
      testStepFail("enter test mode temporary fail","No kostiaResp");
   kostiaReq.long(0)=0xb0b20303;
   kostiaReq.long(4)=0xbaa8aabb;
   output(kostiaReq);
   if (testWaitForMessage(Kostia_Response,100)==1) {
      testStep("enter test mode: second change mode request ","kostiaReq = 0x%llx",$KostiaReq.raw64);
      if ($KostiaResp.raw64 == 0xbaa8aabbb0b20303ll)
         testStepPass("enter test mode permanent success","kostiaResp = 0x%llx",$KostiaResp.raw64);
      else
         testStepFail("enter test mode permanent fail","Wrong kostiaResp = 0x%llx",$KostiaResp.raw64);
   }
   else
      testStepFail("enter test mode permanent fail","No kostiaResp");
}

export void readVersion(void)
{
   message Kostia_Request kostiaReq = {DLC=8};
   char swVer[100];
   int64 swVerGetBytePara;
   int i = 0;
   kostiaReq.long(0)=0x06170004;
   kostiaReq.long(4)=0x0000000c;
   output(kostiaReq);
   if (testWaitForMessage(Kostia_Response,100)==1) {
      testStep("read internal sw version","kostiaReq = 0x%llx",$KostiaReq.raw64);
      if (($KostiaResp.raw64 & 0x04) == 0x04) {
         testStepPass("read internal sw version success","kostiaResp = 0x%llx",$KostiaResp.raw64);
         swVerGetBytePara = 0xff00ll;
         for (i=0;i<6;i++) {
            swVer[i] = (($KostiaResp.raw64 & swVerGetBytePara)>>((i+1)*8));
            swVerGetBytePara <<= 8;
         }
         swVer[++i]='\0';
         testStep("internal sw version","internal sw version is %s.",swVer);
      }
      else
         testStepFail("read internal sw version fail","$KostiaResp = 0x%llx",$KostiaResp.raw64);
   }
   else
      testStepFail("read internal sw version fail","No kostiaResp"); 
}

export void enterSleepModeWithDoorClosed(void)
{
   message Kostia_Request kostiaReq = {DLC=8};
   @sysvar::VTS::M9_Ch1::RelayVBatt = 0;//Brake OFF -- Floating
   sysvar::VTS::M9_Ch2.SetStimulationMode(0);//stim mode inactive
   sysvar::VTS::M9_Ch4.SetStimulationMode(0);//stim mode inactive
   sysvar::VTS::M9_Ch5.SetStimulationMode(0);//stim mode inactive
   sysvar::VTS::M9_Ch6.SetStimulationMode(0);//stim mode inactive
   sysvar::VTS::M9_Ch7.SetStimulationMode(0);//stim mode inactive
   @sysvar::VTS::M9_Ch8::RelayGnd = 0;
   testWaitForTimeout(1000);
   kostiaReq.long(0)=0x00000203;
   kostiaReq.long(4)=0x00000000;
   output(kostiaReq);
   if (testWaitForMessage(Kostia_Response,100)==1) {
      testStep("enter sleep mode","kostiaReq = 0x%llx",$KostiaReq.raw64);
      if ($KostiaResp.raw64 == 0x0203) {
         testStepPass("enter sleep mode success","kostiaResp = 0x%llx",$KostiaResp.raw64);
         testWaitForTimeout(4000);
         if (@sysvar::VTS::M12_Out2::AvgCurrent < 0.0001)
            testStepPass("Current on Sleep Mode","Consumption Current on Sleep Mode with Door Closed is within 0.1mA, sleep current = %5.4fmA",@sysvar::VTS::M12_Out2::AvgCurrent*1000);
         else
            testStepFail("Current on Sleep Mode","Consumption Current on Sleep Mode with Door Closed is larger than 0.1mA, sleep current = %5.4fmA",@sysvar::VTS::M12_Out2::AvgCurrent*1000);
      }
      else
         testStepFail("enter sleep mode fail","Wrong kostiaResp = 0x%llx",$KostiaResp.raw64);
   }
   else
      testStepFail("enter sleep mode fail","No kostiaResp");
}

export void readDTC (int dtcNeedToBeChecked)
{
   message EGSM_diareq egsmDiaReq = {DLC=8};
   message EGSM_resp egsmResp = {DLC=8};
   int frameTimes,i,j,dtcNo;
   dword dtcD[100];
   byte dtcB[400];
   int findCheckedDTC;
   findCheckedDTC = 0;
   egsmDiaReq.long(0)=0xff021903;
   egsmDiaReq.long(4)=0x00000000;
   output(egsmDiaReq);
   testStep("egsmDiaReq","egsmDiaReq = 0x00000000FF021903");
   if (testWaitForMessage(EGSM_resp,200)!=1)
      testStep("egsmResp","egsmResp maybe timeout.");   
   else {
      testGetWaitEventMsgData(egsmResp);
      testStep("egsmResp","egsmResp = 0x%llx",((int64) (egsmResp.long(4))<<32)+(int64) (egsmResp.long(0))); 
      if (egsmResp.byte(0)==0x10) {
         frameTimes = (egsmResp.byte(1)-6)%7==0?(egsmResp.byte(1)-6)/7:(egsmResp.byte(1)-6)/7+1;
         dtcNo = (egsmResp.byte(1)-3)/4;
         dtcB[0] = egsmResp.byte(5);
         dtcB[1] = egsmResp.byte(6);
         dtcB[2] = egsmResp.byte(7);
         egsmDiaReq.long(0)=0x00000030;//0x000A0430
         egsmDiaReq.long(4)=0x00000000;
         testStep("egsmDiaReq","egsmDiaReq = 0x0000000000000030");
         output(egsmDiaReq);
         for (i=0;i<frameTimes;i++) {
            testWaitForMessage(EGSM_resp,200);
            testGetWaitEventMsgData(egsmResp);
            testStep("egsmResp","egsmResp = 0x%llx",((int64) (egsmResp.long(4))<<32)+(int64) (egsmResp.long(0))); 
            for (j=0;j<7;j++) 
               dtcB[3+7*i+j] = egsmResp.byte(j+1);
         }
         for (i = 0;i < dtcNo;i++) 
            dtcD[i]= ((dword)dtcB[i*4]<<24)+((dword)dtcB[i*4+1]<<16)+((dword)dtcB[i*4+2]<<8)+((dword)dtcB[i*4+3]);
      }
      else {
         dtcNo = 1;
         dtcB[0] = egsmResp.byte(4);
         dtcB[1] = egsmResp.byte(5);
         dtcB[2] = egsmResp.byte(6);
         dtcB[3] = egsmResp.byte(7);
         dtcD[0] = ((dword)egsmResp.byte(4))<<24+((dword)egsmResp.byte(5))<<16+((dword)egsmResp.byte(6))<<8+(dword)egsmResp.byte(7);
      }
   }
   testStep("DTC status","Ready to log all the DTCs failed on the current operation cycle in the following.");
   for (i=0;i<dtcNo;i++) {
      if (dtcB[i*4+3] & 0x02 == 0x02) {
         switch ((((word)dtcB[i*4+1])<<8)+(word)dtcB[i*4+2]) {
            case 0x0117: testStep("DTC status","DTC%d = 0x0117:Battery Voltage High",i); break;
            case 0x0216: testStep("DTC status","DTC%d = 0x0216:Battery Voltage Low",i); break;
            case 0x2271: testStep("DTC status","DTC%d = 0x2271:Override Motor Fault",i); break;
            case 0x2319: testStep("DTC status","DTC%d = 0x2319:Override Gear Fault",i); break;
            case 0x8201: testStep("DTC status","DTC%d = 0x8201:Lever Hall Sensor Fault",i); break;
            case 0x3364: testStep("DTC status","DTC%d = 0x3364:Shift Lever Error, P-Release Switch Fault/Park Switch Fault/Safety Switch Fault, Unlock Switch Fault",i); break;
            case 0x4201: testStep("DTC status","DTC%d = 0x4201:PRA Hall Sensor Fault",i); break;
            case 0x4102: testStep("DTC status","DTC%d = 0x4102:PRA Range Fault",i); break;
            case 0x3794: testStep("DTC status","DTC%d = 0x3794:TM Switch Fault",i); break;
            case 0x0404: testStep("DTC status","DTC%d = 0x0404:EEPROM Fault",i); break;
            case 0x1688: testStep("DTC status","DTC%d = 0x1688:CAN Bus Off",i); break;
            case 0x1287: testStep("DTC status","DTC%d = 0x1287:CAN VS_TCU Timeout Fault/CAN G_SEL_DISP Timeout Fault/CAN CF_Tcu_PRelReq Timeout Fault",i); break;
            case 0x4686: testStep("DTC status","DTC%d = 0x4686:CAN VS_TCU Invalid Signal Fault/CAN G_SEL_DISP Invalid Signal Fault",i); break;
            default: testStep("DTC status","DTC%d = 0x%lx",i,((word)dtcB[i*4+1])<<8+dtcB[i*4+2]); break;
         } 
         if (!findCheckedDTC) {
            if ((word)dtcNeedToBeChecked == (((word)dtcB[i*4+1])<<8)+(word)dtcB[i*4+2]) {
               testStepPass("DTC check result","DTC%d = 0x%x occured on the current operation cycle.",i,dtcNeedToBeChecked);
               findCheckedDTC = 1;
            }
         }  
       }
   }
   if (!findCheckedDTC)
      testStepFail("DTC check result","DTC = 0x%x didn't occure on the current operation cycle.",dtcNeedToBeChecked);
}

export void clearDTC (void)
{
   message EGSM_diareq egsmDiaReq = {DLC=8};
   message EGSM_resp egsmResp = {DLC=8};
   egsmDiaReq.long(0)=0xffff1404;
   egsmDiaReq.long(4)=0x000000ff;
   output(egsmDiaReq);
   testStep("egsmDiaReq","egsmDiaReq = 0x000000ffffff1404");
   if (testWaitForMessage(EGSM_resp,200)!=1)
      testStep("egsmResp","egsmResp maybe timeout.");   
   else {
      testGetWaitEventMsgData(egsmResp);
      testStep("egsmResp","egsmResp = 0x%llx",((int64) (egsmResp.long(4))<<32)+(int64) (egsmResp.long(0))); 
      if (egsmResp.long(0)==0xAAAA5401) 
         testStep("clearDTCStatus","clear DTC successfully."); 
      else
         testStep("clearDTCStatus","clear DTC failed."); 
   }
}

export void checkWarningMessage (int checkBit, dword errorcode)
{
   if (TestWaitForSignalOutsideRange(CF_Lvr_ShfErrInf, errorcode, errorcode, 5000)) {
      errorcode = (dword)($CF_Lvr_ShfErrInf) & (((dword)1)<<checkBit);
      if (errorcode == (((dword)checkBit)<<checkBit))
         testStepPass("check CF_Lvr_ShfErrinf", "bit%d = 1,CF_Lvr_ShfErrInf = 0x%lx",checkBit,(dword)($CF_Lvr_ShfErrInf));
      else
         testStepFail("check CF_Lvr_ShfErrinf", "bit%d = 0,CF_Lvr_ShfErrInf = 0x%lx",checkBit,(dword)($CF_Lvr_ShfErrInf));
  
   }
   else 
      testStepFail("check CF_Lvr_ShfErrinf", "CF_Lvr_ShfErrinf has no change,CF_Lvr_ShfErrInf = 0x%lx",(dword)($CF_Lvr_ShfErrInf)); 
}




export testcase checkCF_Lvr_BkeActForBrake (void)
{
   int brakeStatus;
   char fileName[100];
   testValidateTesterConfirmation ("Prepare the graph to see CF_Lvr_BkeAct easily","Prepare the graph to see CF_Lvr_BkeAct easily",1);
   for (brakeStatus = 1; brakeStatus >=0; brakeStatus--) {
      strncpy(fileName,"11.6.3 CF_Lvr_BkeAct",100);
      if (brakeStatus) {
         testStep("brake status","make brake pedal on.");
         strncat(fileName," after brake on.png",100);
      }
      else {
         testStep("brake status","make brake pedal off.");
         strncat(fileName," after brake off.png",100);
      }
      setBrakeStatus (brakeStatus);
      testWaitForTimeout(500);
      if (brakeStatus) 
         testReportAddWindowCapture("Graphics","","CF_Lvr_BkeAct after brake on",fileName);
      else 
         testReportAddWindowCapture("Graphics","","CF_Lvr_BkeAct after brake off",fileName);
      testWaitForTimeout(500);
   }
}

export testcase sendingGearPositionPatternSequence (void)
{
   int vehicleGearPosStatus;
   for (vehicleGearPosStatus = 2;vehicleGearPosStatus <=5;vehicleGearPosStatus++) {
      switch (vehicleGearPosStatus) {
         case 2: testValidateTesterConfirmation("Operate the lever to R.","Operate the lever.",1);break;
         case 3: testValidateTesterConfirmation("Operate the lever to Nr.","Operate the lever.",1);break;
         case 4: testValidateTesterConfirmation("Operate the lever to Nd.","Operate the lever.",1);break;
         case 5: testValidateTesterConfirmation("Operate the lever to D.","Operate the lever.",1);break; 
      }
      checkLeverPositionSendToTcu(vehicleGearPosStatus);
   }
   
}

export testcase unlockSwitchHandling (void)
{
   int unlockSWValid;
   for (unlockSWValid = 0;unlockSWValid < 2; unlockSWValid++) {
      switch (unlockSWValid) {
         case 0:
            testValidateTesterConfirmation("Press yes then release the knob.","Operate the knob.",1);
         break;
         case 1:
            testValidateTesterConfirmation("Press yes then press the knob.","Operate the knob.",1);
         break;
      }
      unlockSWHandling(unlockSWValid);
   }
}

export testcase setIndicatorByVehicleGearPosSentByTCU (int canSigTimeoutBool)
{
   int vehicleGearPosStatus,G_SEL_DISP_value;
   for (vehicleGearPosStatus = 1; vehicleGearPosStatus <= 4; vehicleGearPosStatus++) {
      switch(vehicleGearPosStatus) {
         case 1: testStep("gear position from TCU","vehicleGearPosStatus=P");break;
         case 2: testStep("gear position from TCU","vehicleGearPosStatus=R");break;
         case 3: testStep("gear position from TCU","vehicleGearPosStatus=N");break;
         case 4: testStep("gear position from TCU","vehicleGearPosStatus=D");break;
      }
      setVehicleGearPos(1,canSigTimeoutBool,vehicleGearPosStatus);
      switch(vehicleGearPosStatus) {
         case 1: testValidateTesterConfirmation("check if P indicator is lighten","check LED",1);break;
         case 2: testValidateTesterConfirmation("check if R indicator is lighten","check LED",1);break;
         case 3: testValidateTesterConfirmation("check if N indicator is lighten","check LED",1);break;
         case 4: testValidateTesterConfirmation("check if D indicator is lighten","check LED",1);break;
      }
   }
   testStep("test condition","vehicle gear position is fault");
   setVehicleGearPos(0,canSigTimeoutBool,1);//vehicleGearPosOutput invalid
   testValidateTesterConfirmation("check if SBW will turn off all the indicators","check LED",1);
   testStep("Reset gear position from TCU","Reset vehicleGearPosStatus = P");
   setVehicleGearPos(1,canSigTimeoutBool,1);//Reset vehicleGearPosStatus = P
}


